.hidden[
  https://r.va.gg/2014/06/why-i-dont-use-nodes-core-stream-module.html
  https://nodejs.org/en/docs/guides/backpressuring-in-streams/
]

.center.icon[![otus main](assets/otus-1.png)]

---

class: white
background-image: url(assets/title.svg)
.top.icon[![otus main](assets/otus-2.png)]

# Modern JavaScript Frameworks
## Streams, Errors
### Александр Коржиков

---

class: top white
background-image: url(assets/sound.svg)
.top.icon[![otus main](assets/otus-2.png)]

.sound-top[
  # Как меня слышно и видно?
]

.sound-bottom[
  ## > Напишите в чат
  ### **+** если все хорошо
  ### **–** если есть проблемы cо звуком или с видео
]

---

# Темы предыдущего занятия

.right-image[![Node](assets/node.png)]

- Events
- Event Loop
- Timers

---

# Цели

- Использовать классы, объекты и функции стандартной библиотеки модуля `Streams`
- Работать с ошибками при написании серверного `JavaScript` кода

---

# Темы

.right-image[![](assets/node.png)]

- Streams
- Errors 

---

# Docs


.right-image[![](assets/node.png)]

- [Streams API](https://nodejs.org/api/stream.html)

- [Backpressuring in Streams](https://nodejs.org/en/docs/guides/backpressuring-in-streams/)

- [Why I don't use Node's core 'stream' module - Rod Vagg](https://r.va.gg/2014/06/why-i-dont-use-nodes-core-stream-module.html)


---

# Streams

### Абстрактный интерфейс для работы с потоками данных

```
const stream = require('stream')
```

- Что является потоком в `Node`?
- Для чего нужны потоки?

.center[
![question](assets/question.png)
]

---

# Примеры потоков

- Объекты `request`, `response` HTTP сервера

```
const server = http.createServer((req, res) => {
  res.statusCode = 200 
  res.end()
})
```

- Стандартные потоки ввода-вывода `process.stdin`, `process.stdout`

```
process.stdin.setEncoding('utf8')
process.stdin.on('readable', () => { 
  const chunk = process.stdin.read()
  // ...
})
 
process.stdout.write('end')
// console.log('end')
```

---

# Types of Streams

- Readable - для чтения
- Writable - для записи
- Duplex - комбинация
- Transform - модификация данных
- PassThrough - простейший Transform

.right-image[![stream](assets/node/streams.png)]

---

# Readable API

Streams являются `EventEmitter`

- `on('data')`
- `on('readable')`
- `read()` для чтения

```
let body = []
request.on('data', (chunk) => { 
  body.push(chunk)
})
.on('end', () => { 
  body = Buffer.concat(body).toString()
})
```

---

# Writable API

Является `EventEmitter`

- `write()`, `end()` для Writable

```
response.write('<html>')
response.write('<body>')
response.write('<h1>Hello, World!</h1>')
response.write('</body>')
response.write('</html>')
response.end()
```

---

# HTTP Server

```
const http = require('http')
http.createServer((request, response) => {
  const { headers, method, url } = request
  let body = [] 
  
  request.on('data', (chunk) => {
    body.push(chunk)
  })
  .on('end', () => {
    body = Buffer.concat(body).toString() 
    response.statusCode = 200 
    response.setHeader('Content-Type', 'application/json') 
    const responseBody = { headers, method, url, body }
    response.write(JSON.stringify(responseBody)) 
    response.end()
  })
})
.listen(8080)
```

- Что можно добавить?

---

# Задача

Использовать стандартные потоки `process.stdin`, `process.stdout` для ввода имени из командной строки

```bash
node index.js

enter your name
Alex
your name is Alex
```

```
http.createServer((request, response) => {
  request.on('data', () => {
    /* ... */
  })
  .on('end', () => {
    response.write(/* ... */) 
    response.end()
  })
})
```

---

# Объекты аргументы

.hidden[
  https://medium.freecodecamp.org/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8
]

- `Buffer, String` стандартно
- `Object` опционально с `objectMode`

```
const stream = require('stream')
const readable = (function() { 
  const data = [] 
  const $ = new stream.Readable({ objectMode: true, read() {} }) 
  $.push({ a: 1 }) 
  return $
})()

readable.on('data', (data) => { 
  console.log(data)
})
```

---

# Создание потоков

- `new Writable()` - конструктор
- `class MyWritable extends Writable` - класс

```
const stream = require('stream')
const writable = (function(){ 
  const data = [] 
  const $ = new stream.Writable({ 
    write(chunk, encoding, callback) { 
      data.push(chunk.toString()) 
      callback() 
    } 
  }) 
  return $
})()

writable.write('some data')
writable.end('done writing data')
writable.on('finish', () => { 
  console.log('All writes are now complete.')
})
```

---

# Pipe

`Readable.pipe()` связывает поток, передавая все данные в `Writable`

```
readable.on('data', (chunk) => { 
  writable.write(chunk)
})

readable.on('end', () => { 
  writable.end()
})
// -> 
readable.pipe(writable)
```

.half-image[![pipe](assets/stream/pipe.png)]

---

# Buffering


- `highWaterMark` - размер буфера
- `writable.write()` - `true / false`
- `drain` - событие продолжения

.half-image[![highWaterMark](assets/stream/highWaterMark.png)]

---

# Demo

```
// node/stream/read.js

const { Readable } = require('stream')
const WORD = '1234567890'

var read = new Readable();

while(true) {
  new Array(100)
    .fill('')
    .map(() => read.push(WORD))
    .forEach((err) => console.log(err))
}
```

---

# Задача

Использовать стандартные потоки и `pipe` для вывода вводимых данных

```bash
node index.js

abc
abc
123
123
```

---

class: white
background-image: url(assets/title.svg)
.top.icon[![otus main](assets/otus-2.png)]

# Streams Q&A

---

# Errors

- Стандартные типы ошибок JavaScript
- Системные ошибки при использовании API
- Assertion Errors
- User Errors

---

# Вопрос - Стандартные ошибки

### Что к чему относится?

.left-code[
```
1. EvalError 
2. SyntaxError
3. RangeError
4. ReferenceError
5. TypeError
6. URIError
```
]

.right-code[
```
/*a*/ var a = undefinedVariable
/*b*/ throw new EvalError('error')
/*c*/ decodeURIComponent('%')
/*d*/ eval('hoo bar')
/*e*/ undefined.not()
/*f*/ [].length = 'Wat?'
```
]

---

# Вопрос

Какие способы обработки ошибок вы знаете?

```
require('fs')
 .readdir('not exist', () => { 
   throw new Error('test') 
  })
```

---

# Способы обработки ошибок

- try / catch / finally 
- callback(err, res)
- on('error')
- Promise.reject()

```
try { 
  require('not exist')
} 
catch(e) { 
  debugger
} 
finally { 
  console.log('go on')
}
```

---

# Вопрос

### Что здесь не так?

```
try { 
  require('fs')
    .readdir('not exist', () => { 
      throw new Error('test') 
    })
} catch(e) { 
  console.log('error')
}
```

---

# Создание ошибок

### Конструктор
- .red[new Error(message)]

### Свойства
- error.message
- error.code - строка константа `E_ERROR_TITLE`
- error.stack с .green[Error.captureStackTrace(error)]

---

# Process Events

.right-image[![Node](assets/node.png)]

### EventEmitter
- .blue['error'] - всегда определять обработчик

### Process
- .blue['uncaughtException'] - возможность последнего слова
- .blue['unhandledRejection'] - необработанные Promise

---

# Demo

С помощью `process.on('uncaughtException')` перехватить и залогировать собственный тип ошибки (без использования конструктора `Error`, но включая стэк)

```bash
node error.js
Error
./errors/error.js:2:9)
    at emitOne (events.js:116:13)
    at process.emit (events.js:211:7)
    at process._fatalException (bootstrap_node.js:374:26)
```

---

# How To Error

- .green[DO] use Promises / async / await with catch() 
- .green[DO] use Error class
- .red[DO NOT] throw 'strings or something'
- .green[DO] use central error handling and logging
- .red[DO NOT] continue with unknown 'uncaughtException'
- .green[DO] 'unhandledRejection' handling

---

class: white
background-image: url(assets/title.svg)
.top.icon[![otus main](assets/otus-2.png)]

# Errors Q&A

---

# На занятии

- Работали с классами, объектами и функциями стандартной библиотеки модуля `Streams`
- Разобрали примеры обработки ошибок при написании серверного `JavaScript` кода

---

# Modern JavaScript Frameworks

.mario.mario-4[![mario](assets/mario.png)]
<!-- .mario.mushroom[![mushroom](assets/mario_mushroom.png)] -->

| ![JS](assets/icons/trim/js.png) | ![Node](assets/icons/trim/node.png) | ![Web Components](assets/icons/trim/webcomponents.png) | ![React](assets/icons/trim/react.png) | ![Vue](assets/icons/trim/vue.png) | ![Angular](assets/icons/trim/angular.png) |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| ![Google Chrome](assets/icons/trim/google_chrome.png) | ![NPM](assets/icons/trim/npm.png) | ![polymer](assets/icons/trim/polymer.png) | ![redux](assets/icons/trim/redux.png) | | ![ts](assets/icons/trim/ts.png) |
| | ![v8](assets/icons/trim/v8.png) | | ![react-router](assets/icons/trim/react-router.png) | | ![rxjs](assets/icons/trim/rxjs.png) |
| | ![Express](assets/icons/trim/express.png) | |
| | ![GraphQL](assets/icons/trim/graphql.png) | |

---

# Задача

### Написать приложение для работы с потоками: 
- `Readable`, генерирующий случайные числа, 
- `Transformable`, добавляющий случайное число к первому и 
- `Writable`, выводящий в консоль данные

### Данные должны "течь" readable > transformable > writable
### Используйте `highWaterMark` для примера ограничения внутреннего буффера

---

class: white
background-image: url(assets/title.svg)
.top.icon[![otus main](assets/otus-2.png)]

# Спасибо за внимание!
.black[ 
## Пожалуйста, пройдите опрос 
## в личном кабинете 
]